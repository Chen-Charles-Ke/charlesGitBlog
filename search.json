[{"title":"Swift Utility Component - UserDefaults","url":"/charles-blog/2021/11/12/userDefaults/","content":"Build a mature utility class can store &amp; read &amp; delete local cashed defaults.                           \nPreface：we always facing requirements from business team/PO in the daily development progress, which like following cases :\na). when customer login back App after first time login and logout, customer profile name or nickname expected as login username.\nb). lets say there is a screen has carousel cards , or the muti-view component, customer logout from this screen, we are expected back to same card indicator or specific view after customer next logon.\n…\nAnalysis：For the above business scenarios, we need to store the user’s login name, passing the index of the current view into userdefaults when exiting the app, and then read the stored key value after opening App.\nSo, Its time to build a completely, flexibility, Out-of-the-box userDefaults utility.\nimplementation:Step1, we build a Class to define User Actions UserAction.swiftimport Foundationpublic enum UserAction: String &#123;    case firstLogin    case indicatorIndex    func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    public var name: Stirng &#123;        rawValue    &#125;&#125;\n\nimport Foundationpublic enum UserAction: String &#123;    case test    case test2&#125;\n\nimport Foundationimport Combinepublic protocol DataStore &#123;    func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func delete(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\n\nhere we define a enum struct which type is String , and give a name as the key value we will pass to UserDefault later.\nStep2, we define a DataStore protocol, class which conform to this protocl expected overwrite the function methods(write, read, delete) inside the protocol.import Foundationimport Combinepublic protocol DataStore &#123;    func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func delete1(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\n\nimport Foundationimport Combimepublic protocol DataStore &#123;    func red&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func write&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func delete&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;&#125;\n\nyou must noticed that above three methods will return a new publisher.\nStep3, we need a UserDefaultsStore.swift class to conform this protocol.import Foundationimport Combinepublic class UserDefaultsStore: DataStore &#123;    private let userDefaults: UserDefaults    private let decoder: JSONDecoder    private let encoder: JSONEncoder        init(        userDefaults: UserDefaults,        decoder: JSONDecoder,        encoder: JSONEncoder    ) &#123;        self.userDefaults = userDefaults        self.decoder = decoder        self.encoder = encoder    &#125;        public func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt; &#123;        Just(key)            .tryMap &#123; key -&gt; T? in                guard let data = userDefaults.data(forKey: key) else &#123; return nil &#125;                return try decoder.decode(T.self, from: data)            &#125;.eraseToAnyPublisher()    &#125;        public func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        Just(())            .tryMap &#123; emptyValue -&gt; Void in                let data = try encoder.encode(value)                userDefaults.set(data, forKey: key)                return emptyValue            &#125;.eraseToAnyPublisher()            &#125;        public func delete(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaults.removeObject(forKey: key)        return Just(()).setFailureType(to: Error.self).eraseToAnyPublisher()    &#125;&#125;\nStep4, we will build a StandardUserActionsManager Class, and make the final encapsulation.A, we will define a UserActionsManager protocolpublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\nB, lets extend UserDefaultStore, and convenience init this class by using id which passed from customer username ID or the .standard provided by systerm.public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nC, we make StandardUserActionsManager to conform UserActionsManager protocol.import Foundationimport Combinepublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;public class StandardUserActionsManager: UserActionsManager &#123;        private let userDefaultsStore: UserDefaultsStore    private var cancellabes = Set&lt;AnyCancellable&gt;()        init(        userDefaultsStore: UserDefaultsStore    ) &#123;        self.userDefaultsStore = userDefaultsStore    &#125;            public func writeToDefaults&lt;T&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; where T : Encodable &#123;        userDefaultsStore            .write(userAction.name, value: value)            .eraseToAnyPublisher()    &#125;        public func readFromDefaults&lt;T&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt; where T : Decodable &#123;        userDefaultsStore            .read(userAction.name)            .eraseToAnyPublisher()    &#125;        public func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaultsStore            .delete(userAction.name)            .eraseToAnyPublisher()    &#125;    &#125;public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nIn this way, our UserDefaults Utility is completed. When we introduce the function of storage and reading in the business, we directly instantiate this class to realize the requirements.\nDemo Testing:After tapping the = sign here, a calculation result will be displayed. if we do not store and read defaults, when we exit the app, the result will obviously be cleared. After we finish storing and reading, the calculation result will still be displayed after opening the app.\n\n"}]