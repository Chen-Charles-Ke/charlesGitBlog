[{"title":"Swift UI Component - Segemented Picker","url":"/charles-blog/2021/11/13/tabBar/","content":"Preface:You will not be unfamiliar with Segemented Picker, or the tab bar selector, its a common component. Generally we can switch to another screen/view by tapping the different tab index. \nBut the problem we facing is, there are different design types of your segemented picker, in order to maintain the uniform style of design screen elements, your designer will ask you build several different-looking components which have same funtionality.  \nsuch as:  \n\npicker has underline\npicker has marker state\ntab type picker\ndifferent background color picker\n\nToday i will walk though you to build a extensible component that will never let your desinger trouble you again.  lets start it!\nImplementation:Step1. Lets write a enum to define all the segemented control types we might need.public enum SegementedControlType &#123;    case underline    case tab    case blackRoundTab&#125;\n\nStep2. Input for segemented control.public struct SegmentedTabContent &#123;    /// Segment tab text    public var text: String    /// Segment tab red marker end of text    @Binding public var markerState: Bool    /// Init segmentedTabContent    public init(text: String, markerState: Binding&lt;Bool&gt; = .constant(false)) &#123;        self.text = text        _markerState = markerState    &#125;&#125;\ntext which type is String will as the label name displaying over somewhere, and we give a tag makerState here to show the red maker(which represents unread status) or not.\nBefore next step, id like to write a segmented control configuration typealias for convenience.\npublic typealias SegmentedControlConfiguration = (textColor: Color, selectTextColor: Color)\n\ntextColor is the tab label color and selectTextColor is the tab selected color.\nStep3. Lets start working on the View stuff.public struct SegmentedControl: View &#123;    // MARK: - Private fields    @Binding private var selection: Int    private var items: [SegmentedTabContent]    private var isFullWidth: Bool    @State private var sizes: [Int: CGSize] = [:]    private let type: SegmentedControlType    private var onSelect: ((SegmentedTabContent, Int) -&gt; Void)?    private var configuration = SegmentedControlConfiguration(textColor: Color(.gray), selectTextColor: Color(.black))    private var scrollEnable: Bool = false    private var spacingBetweenItem: CGFloat &#123;        type == .underline            ? 30            : 20    &#125;    private var offsetX: CGFloat &#123;        var totalWidth: CGFloat = 0        for idx in 0 ..&lt; selection &#123;            totalWidth += sizes[idx]?.width ?? 0        &#125;        return totalWidth + (CGFloat(selection) * spacingBetweenItem)    &#125;    private var contentLineBackground: some View &#123;        Rectangle()            .fill(Color(.black))            .frame(                width: sizes[selection]?.width ?? 0,                height: 2.0            )            .offset(x: offsetX)    &#125;    private var contentTabBackground: some View &#123;        Rectangle()            .fill(Color(.white))            .frame(                width: sizes[selection]?.width ?? 0,                height: 30            )            .cornerRadius(10)            .shadow(                color: Color.black.opacity(0.05),                radius: 4            )            .offset(x: offsetX)    &#125;    private var contentBlackTabBackground: some View &#123;        Rectangle()            .fill(Color(.black).opacity(0.5))            .frame(                width: sizes[selection]?.width ?? 0,                height: 28            )            .cornerRadius(14)            .shadow(                color: Color.black.opacity(0.05),                radius: 4            )            .offset(x: offsetX)    &#125;    // MARK: - Private methods    private func itemView(index: Int) -&gt; some View &#123;        let foregroundColor = selection == index ? configuration.selectTextColor : configuration.textColor        let paddingHorizontal: CGFloat            = (type == .underline || type == .titleUnderline) ? 0.0 : 10.0        return ZStack &#123;            VStack &#123;                Spacer()                Text(items[index].text)                    .kerning(0.6)                    .font(.system(size: 12, weight: .medium))                    .foregroundColor(foregroundColor)                    .lineLimit(1)                    .padding(.horizontal, paddingHorizontal)                    .overlay(                        Circle()                            .strokeBorder(Color(.white), lineWidth: 1)                            .background(Circle().foregroundColor(Color(.red)))                            .frame(width: 9, height: 9)                            .opacity(items[index].markerState ? 1 : 0)                            .offset(x: 9, y: -9),                        alignment: .topTrailing                    )                Spacer()            &#125;            .frame(maxWidth: .none)            .background(                VStack &#123;                    if index == selection &amp;&amp; type == .titleUnderline &#123;                        Spacer()                        Rectangle()                            .fill(Color(.black))                                .frame(height: 2)                    &#125;                &#125;            )        &#125;        .frame(maxWidth: isFullWidth ? .infinity : .none, maxHeight: .infinity)        .contentShape(Rectangle())        .background(            GeometryReader &#123; geo -&gt; Color in                DispatchQueue.main.async &#123;                    sizes[index] = geo.frame(in: .global).size                &#125;                return Color.clear            &#125;        )        .onTapGesture &#123;            withAnimation &#123;                selection = index                self.onSelect?(items[index], index)            &#125;        &#125;    &#125;    // MARK: - Initializer    /// Init.    public init(        type: SegmentedControlType = .underline,        selection: Binding&lt;Int&gt; = .constant(0),        items: [SegmentedTabContent],        isFullWidth: Bool = false,        onSelectTab: ((SegmentedTabContent, Int) -&gt; Void)? = nil,        configuration: SegmentedControlConfiguration? = nil,        scrollEnable: Bool? = false    ) &#123;        self.type = type        _selection = selection        self.items = items        self.isFullWidth = isFullWidth        onSelect = onSelectTab        if let config = configuration &#123;            self.configuration = config        &#125;        if let scroll = scrollEnable &#123;            self.scrollEnable = scroll        &#125;    &#125;    // content    private func content() -&gt; some View &#123;        HStack(spacing: spacingBetweenItem) &#123;            ForEach(items.indices, id: \\.self) &#123; index in                itemView(index: index)            &#125;        &#125;        .padding(.top, 3)        .background(            ZStack &#123;                if type == .underline &#123;                    contentLineBackground                &#125; else if type == .tab &#123;                    contentTabBackground                &#125; else if type == .blackRoundTab &#123;                    contentBlackTabBackground                &#125;            &#125;,            alignment: type == .underline ? .bottomLeading : .leading        )    &#125;    /// Body.    public var body: some View &#123;        VStack(alignment: .leading, spacing: 0) &#123;            if scrollEnable &#123;                ScrollView(.horizontal) &#123;                    content()                &#125;            &#125; else &#123;                content()            &#125;        &#125;        .frame(maxHeight: .infinity)        .frame(height: 44)    &#125;&#125;\nDemonstration:\n\n\n","categories":["Swift UI Component"]},{"title":"Swift Utility Component - UserDefaults","url":"/charles-blog/2021/11/12/userDefaults/","content":"Build a mature utility class can store &amp; read &amp; delete local cashed defaults.                           \nPreface：we always facing requirements from business team/PO in the daily development work, which like following cases :\na). when customer login back after exsiting App, login screen username expected as profile name or nickname.\nb). lets say there is a screen has carousel cards , or the muti-view component, customer logout from this screen with a specsific indicator index, we are expected back to same card indicator or specific view after customer next logon.\n…\nAnalysis：For the above business scenarios, we need to store the user’s login name, and passing the index of the current view into userdefaults when exiting the app, then read the stored key value after opening App.\nSo, Its time to build a completely, flexibility, Out-of-the-box userDefaults utility.\nImplementation:Step1, we build a Class that represents user actions UserAction.swiftimport Foundationpublic enum UserAction: String &#123;    case firstLogin    case indicatorIndex    public var name: Stirng &#123;        rawValue    &#125;&#125;\n\nhere we define a enum struct which type is String , and give a name as the key value we will pass to UserDefault later.\nStep2, we define a DataStore protocol, class which conform to this protocl expected overwrite the function methods(write, read, delete) inside the protocol.import Foundationimport Combinepublic protocol DataStore &#123;    func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func delete1(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\n\nyou may noticed that above three methods will return a new publisher.\nStep3, we need a UserDefaultsStore.swift class to conform this protocol.import Foundationimport Combinepublic class UserDefaultsStore: DataStore &#123;    private let userDefaults: UserDefaults    private let decoder: JSONDecoder    private let encoder: JSONEncoder        init(        userDefaults: UserDefaults,        decoder: JSONDecoder,        encoder: JSONEncoder    ) &#123;        self.userDefaults = userDefaults        self.decoder = decoder        self.encoder = encoder    &#125;        public func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt; &#123;        Just(key)            .tryMap &#123; key -&gt; T? in                guard let data = userDefaults.data(forKey: key) else &#123; return nil &#125;                return try decoder.decode(T.self, from: data)            &#125;.eraseToAnyPublisher()    &#125;        public func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        Just(())            .tryMap &#123; emptyValue -&gt; Void in                let data = try encoder.encode(value)                userDefaults.set(data, forKey: key)                return emptyValue            &#125;.eraseToAnyPublisher()            &#125;        public func delete(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaults.removeObject(forKey: key)        return Just(()).setFailureType(to: Error.self).eraseToAnyPublisher()    &#125;&#125;\nStep4, we will build a StandardUserActionsManager Class, and make the final encapsulation.A, we will define a UserActionsManager protocolpublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\nB, lets extend UserDefaultStore, and convenience init this class by using id which passed from customer username ID or the .standard provided by systerm.public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nC, we make StandardUserActionsManager to conform UserActionsManager protocol.import Foundationimport Combinepublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;public class StandardUserActionsManager: UserActionsManager &#123;        private let userDefaultsStore: UserDefaultsStore    private var cancellabes = Set&lt;AnyCancellable&gt;()        init(        userDefaultsStore: UserDefaultsStore    ) &#123;        self.userDefaultsStore = userDefaultsStore    &#125;            public func writeToDefaults&lt;T&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; where T : Encodable &#123;        userDefaultsStore            .write(userAction.name, value: value)            .eraseToAnyPublisher()    &#125;        public func readFromDefaults&lt;T&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt; where T : Decodable &#123;        userDefaultsStore            .read(userAction.name)            .eraseToAnyPublisher()    &#125;        public func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaultsStore            .delete(userAction.name)            .eraseToAnyPublisher()    &#125;    &#125;public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nIn this way, our UserDefaults Utility is completed. When we introduce the function of storage and reading in the business, we directly instantiate this class to realize the requirements.\nDemo Testing:After tapping the = sign here, a calculation result will be displayed. if we do not store and read defaults, when we exit the app, the result will obviously be cleared. After we finish storing and reading, the calculation result will still be displayed after opening the app.\n\n","categories":["Swift Utility Component"]},{"title":"Swift Notebook - @ViewBuilder","url":"/charles-blog/2021/11/12/viewBuilder/","content":"Alright, id say if you want to use @ViewBuilder, I ventured infer that the basic swiftUI elements and components can no longer meet the complex requirements or customization requirements of your project. We need to DIY the more extensible view.  \nToday, let’s take a good look at this @ViewBuilder\nimport SwiftUIstruct ContentView: View &#123;    var body: some View &#123;        HStack&#123;            Text(&quot;hello&quot;)            Text(&quot;world&quot;)        &#125;    &#125;&#125;\nVery simple hello world level swiftUI code huh? as all we know, in the world of swiftUI, everything is a view, but have you ever thought about why we put two text views in hstack, so they can be aligned horizontally, and why hstack can accept two views?   \nLet’s click into hstack’s definition to have a look:\n@inlinable public init(    alignment: VerticalAlignment = .center,    spacing: CGFloat? = nil,    @ViewBuilder content: () -&gt; Content)\nFrom the source code, we can see that there is a closure content modified by @Viewbuilder in the init method, which means that the expression inside the closure needs to be processed by @Viewbuilder. How to handle it? When compiling the closure decorated by @Viewbuilder, swift will first try to find the static buildblock method in the @Viewbuilder structure. This method has two views as parameters. \nLet’s take a look first:\n@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)extension ViewBuilder &#123;    public static func buildBlock&lt;C0, C1&gt;(_ c0: C0, _ c1: C1) -&gt; TupleView&lt;(C0, C1)&gt; where C0 : View, C1 : View&#125;\nFrom the source code of this viewbuilder, we can see that it receives two views as input parameters and returns a tupleview combined with two views.If you read the source code, you will find other statements:\n@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)extension ViewBuilder &#123;    public static func buildBlock&lt;C0, C1, C2, C3, C4, C5, C6, C7, C8, C9&gt;(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -&gt; TupleView&lt;(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)&gt; where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View, C9 : View&#125;\nWhat is tupleview?\n\nTupleview is a view created from a quick tuple of view values. Tupleview has no logic inside. It only keeps the view. Tupleview is completely transparent and behaves like its parent view. This means that when you put it into hstack, tupleview will place the view from tuples horizontally.\n\nAlright, now that we understand the role of @Viewbuilder, let’s think about how to use it.\nSuppose we want to do notification function for our app. First, we think that this notification should be componentized, but the content of our notification should be diversified and customized. oh yeah, we can use @Viewbuilder.\nimport SwiftUIstruct NotificationView&lt;Content: View&gt;: View &#123;    let content: Content    init(@ViewBuilder content: () -&gt; Content) &#123;        self.content = content()    &#125;    var body: some View &#123;        content            .padding()            .background(Color(.tertiarySystemBackground))            .cornerRadius(16)            .transition(.move(edge: .top))            .animation(.spring())    &#125;&#125;\nWe build a notificationview here. In this view, we draw the basic style of notification, but the type of content is a closure decorated by @Viewbuilder. This lays a foundation for us to customize the push content later.\nWhen we want to use this notificationview, we can:\nimport SwiftUIstruct ContentView: View &#123;    @State private var notificationShown = false    var body: some View &#123;        VStack &#123;            if self.notificationShown &#123;                NotificationView &#123;                    Text(&quot;notification&quot;)                &#125;            &#125;            Spacer()            Button(&quot;toggle&quot;) &#123;                self.notificationShown.toggle()            &#125;            Spacer()        &#125;    &#125;&#125;","categories":["Swift Notebook"]}]