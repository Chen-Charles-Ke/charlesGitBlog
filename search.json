[{"title":"iOS Concurrency Section 1","url":"/charles-blog/2021/11/28/ConcurrencySection1/","content":"Each of us is smartphone user, thinking about one thing, when will you feel like “oh shit this app too slow” on some apps ?  i guess, lets say there is a next button and the screen stutter there like 1 sec after you tap it. In this article and subsequent series of articles, lets start learning how to build an App which is “no shit”.\nWhat is concurrency?Wikipedia defines concurrency as \n\nthe decomposability property of a program, algorithm, or problem into order-independent or partially-ordered components or units.\n\nWell I know every word above but when they are put together I don’t understand at all.\nBefore concurrency, lets introduce some a few concepts.\n\nSynchronous and Asynchronous\n\nWhen we talk about thread execution, synchronous and asynchronous are the most basic set of concepts in this topic. Synchronous operation means that the thread running the operation will be occupied before the operation is completed. Until the function is finally thrown or returned.\nBefore swift 5.5, all the func in swift is synchronus func, lets give a example func.\n\nsome of you guys might know that swift 5.5 bring us a new concurrency await/async systerm, we are not start learing concurrency from this because it will be long time we able to introduce it to production level project. but i will write some chapter of “new concurrency” at end of this topic. Dont worry about you are wasting your time to learn outdated knowledge, In fact, this knowledge is the necessary foundation, otherwise you will feel very confused when learning new concepts.\n\nvar results: [String] = []func addAppending(_ value: String, to string: String) &#123;    results.append(value.appending(string))&#125;\nAddAppending is a synchronous function. Before it returns, the thread running it will not be able to perform other operations, or it cannot be used to run other functions. It must wait for the current function to complete before the thread can do other things.\n  \n\n\n\nIn iOS development, we build the screen with UIKit or SwiftUI,which is not thread-safe: the processing of user input and the drawing of the UI must be performed in the main runloop bound to the main thread. Suppose we want The user interface runs at a rate of 60 frames per second, so the processing time allowed between each two draws in the main thread is only 16 milliseconds (1/60s) at most. When other operations to be synchronized in the main thread are time-consuming Less time (such as our addAppending, which may take only tens of nanoseconds), this will not cause any problems. However, if this synchronization operation takes too long, the main thread will be blocked. It cannot accept user input, and Unable to submit a request to the GPU to draw a new UI, which will cause the user interface to drop frames or even freeze. This kind of “long time-consuming” operation is actually very common, such as:\n\nreceiving data from a network request\nloading one large files from disk \ncomplex encryption and decryption operations\n\nLets give another example of this, we have a loadSignature func which can read signature from remote service, and this operation will performe in the  main thread, as well as it spend more than 16 milliseconds, which is cause main thread wont handle other operations, UI wont refresh.\nfunc loadSignature() throws -&gt; String? &#123;    let data = try Data(contentsOf: someURL)    return String(data: data, encoding: .utf8)&#125;\n  \n\n\n\nIn the user’s perception, it will appear as dropped frames or the entire screen stuck. This is one of the problems that must be avoided in client development.\nThe most common way to solve this problem was to convert time-consuming synchronous operations into asynchronous operations: put the actual long-running tasks in another thread (or background thread) to run, and then at the end of the operation Provide callbacks running on the main thread for UI operations\nfunc loadSignature(_ completion: @escaping (String?, Error?) -&gt; Void) &#123;    DispatchQueue.global().async &#123;        do &#123;            let d = try Data(contentsOf: someURL)            DispatchQueue.main.async &#123;                completion(String(data: d, encoding: .utf8), nil)            &#125;        &#125; catch &#123;            DispatchQueue.main.async &#123;                completion(nil, error)            &#125;        &#125;    &#125;&#125;\n\n  \n\n\n\nWe call the act of loading data in a background thread as asynchronous operation.  \n\nSerial and Parallel\n\nFor the synchronization operations performed by the synchronization method, these operations must occur in the same thread in a serial manner. “Finish one thing, and then proceed to the next thing” is the most common, and the easiest way for humans to understand code execution.\nif let signature = try loadSignature() &#123;    addAppending(signature, to: &quot;some data&quot;)&#125;print(results)\nloadSignature, addAppending, and print are called sequentially, and they occur in strict order in the same thread. We call this execution as serial.\n  \n\n\n\nThe synchronous operation performed by the synchronous method is a sufficient but not necessary condition for serial. Asynchronous operations may also be executed serially. Suppose that in addition to loadSignature(_:), we also have a function that reads a series of data from the database. It uses a similar method to put specific work on other threads for asynchronous execution:\n“func loadFromDatabase(_ completion: @escaping ([String]?, Error?) -&gt; Void) &#123;// ...&#125;\nIf we first read the data from the database, and then use loadSignature to get the signature from the network after completion, and finally append the signature to each string retrieved from the database, we can write:\nloadFromDatabase &#123; (strings, error) in    if let strings = strings &#123;        loadSignature &#123; signature, error in            if let signature = signature &#123;                strings.forEach &#123;                    addAppending(signature, to: $0)                &#125;            &#125; else &#123;                print(&quot;Error&quot;)            &#125;        &#125;    &#125; else &#123;        print(&quot;Error.&quot;)    &#125;&#125;\nAlthough these operations are asynchronous, they (read [String] from the database, download the signature from the network, and finally add the signature to each piece of data) are still serial, and the loading of the signature must happen after the database is read. And the final addAppending must also happen after loadSignature.\n  \n\n\n\nIn fact, although the final addAppending task requires both the original data and the signature to proceed, there is actually no dependency between loadFromDatabase and loadSignature. If they can be executed together, our program has a high chance of becoming faster. At this time, we will need more threads to perform two operations at the same time and we can replace the serial calls with parallel calls.\nThe two load methods start working at the same time. In theory, if the resources are sufficient (enough CPU, network bandwidth, etc.)\n\nModerns devices almost always have more than a single CPU, and Apple’s iPhones have been dual core since 2011. Having more than one core means they are capable of running more than a single task at the same time. By splitting your app into logical “chunks” of code you enable the iOS device to run multiple parts of your program at the same time, thus improving overall performance.\n\nAnd time they consume will now be less than the sum of the two in serial.\n  \n\n\n\nthe two asynchronous operations, loadFromDatabase and loadSignature, are executed simultaneously in different threads. For this way of having multiple sets of resources executed at the same time, we call it as parallel.\nLast, I would like give you the final anwser of “what is concurrency”:\n\nConcurrency = a combination of asynchronous and parallel code\n\nhow to use concurrency?\nGCD and Operation\n\nthere are two main ways that iOS provides you with the ability to run code concurrently.\n\nGrand Central Dispatch (GCD)\nOperation\n\n\nGCD is Apple’s implementation of C’s libdispatch library. Its purpose is to queue up tasks — either a method or a closure — that can be run in parallel, depending on availability of resources; it then executes the tasks on an available processor core.\n\nAs a developer, you needent worry about how to manage thread yourself, GCD will help you do that through only 15 instructions. All of the tasks that GCD manages for you are placed into GCD-managed first-in, first-out (FIFO) queues. Each task that you submit to a queue is then executed against a pool of threads fully managed by the system.\nand GCD makes running async task very simple via closures with few lines of code:\n// Class level variablelet queue = DispatchQueue(label: &quot;charlesLabel&quot;)// Somewhere in your functionqueue.async &#123;  // Call slow non-UI methods here    DispatchQueue.main.async &#123;    // Update the UI here  &#125;&#125;\n\nOperations are fully-functional classes that can be submitted to an OperationQueue, just like you’d submit a closure of work to a DispatchQueue for GCD. Because they’re classes and can contain variables, you gain the ability to know what state the operation is in at any given point.\nOperations can exist in any of the following states:\n\nisReady\n\nisExecuting\n\nisCancelled\n\nisFinished\n\nWhich should you use?\n\nThere’s no clear-cut directive as to whether you should use GCD or Operations in your app. GCD tends to be simpler to work with for simple tasks you just need to execute and forget. Operations provide much more functionality when you need to keep track of a job or maintain the ability to cancel it.\nIn the next section, i will take you go through more about GCD. \n","categories":["Swift Notebook"]},{"title":"Swift UI Component - Segemented Picker","url":"/charles-blog/2021/11/13/tabBar/","content":"Preface:You will not be unfamiliar with Segemented Picker, or the tab bar selector, its a common component. Generally we can switch to another screen/view by tapping the different tab index. \nBut the problem we facing is, there are different design types of your segemented picker, in order to maintain the uniform style of design screen elements, your designer will ask you build several different-looking components which have the same functionality.  \nsuch as:  \n\npicker has underline\npicker has marker state\ntab type picker\ndifferent background color picker\n\nToday i will walk though you to build a extensible component that will never let your desinger trouble you again.  lets start it!\nImplementation:Step1. Lets write a enum to define all the segemented control types we might need.public enum SegementedControlType &#123;    case underline    case tab    case blackRoundTab&#125;\n\nStep2. Input for segemented control.public struct SegmentedTabContent &#123;    /// Segment tab text    public var text: String    /// Segment tab red marker end of text    @Binding public var markerState: Bool    /// Init segmentedTabContent    public init(text: String, markerState: Binding&lt;Bool&gt; = .constant(false)) &#123;        self.text = text        _markerState = markerState    &#125;&#125;\ntext which type is String will as the label name displaying over somewhere, and we give a tag makerState here to show the red maker(which represents unread status) or not.\nBefore next step, id like to write a segmented control configuration typealias for convenience.\npublic typealias SegmentedControlConfiguration = (textColor: Color, selectTextColor: Color)\n\ntextColor is the tab label color and selectTextColor is the tab selected color.\nStep3. Lets start working on the View stuff.public struct SegmentedControl: View &#123;    // MARK: - Private fields    @Binding private var selection: Int    private var items: [SegmentedTabContent]    private var isFullWidth: Bool    @State private var sizes: [Int: CGSize] = [:]    private let type: SegmentedControlType    private var onSelect: ((SegmentedTabContent, Int) -&gt; Void)?    private var configuration = SegmentedControlConfiguration(textColor: Color(.gray), selectTextColor: Color(.black))    private var scrollEnable: Bool = false    private var spacingBetweenItem: CGFloat &#123;        type == .underline            ? 30            : 20    &#125;    private var offsetX: CGFloat &#123;        var totalWidth: CGFloat = 0        for idx in 0 ..&lt; selection &#123;            totalWidth += sizes[idx]?.width ?? 0        &#125;        return totalWidth + (CGFloat(selection) * spacingBetweenItem)    &#125;    private var contentLineBackground: some View &#123;        Rectangle()            .fill(Color(.black))            .frame(                width: sizes[selection]?.width ?? 0,                height: 2.0            )            .offset(x: offsetX)    &#125;    private var contentTabBackground: some View &#123;        Rectangle()            .fill(Color(.white))            .frame(                width: sizes[selection]?.width ?? 0,                height: 30            )            .cornerRadius(10)            .shadow(                color: Color.black.opacity(0.05),                radius: 4            )            .offset(x: offsetX)    &#125;    private var contentBlackTabBackground: some View &#123;        Rectangle()            .fill(Color(.black).opacity(0.5))            .frame(                width: sizes[selection]?.width ?? 0,                height: 28            )            .cornerRadius(14)            .shadow(                color: Color.black.opacity(0.05),                radius: 4            )            .offset(x: offsetX)    &#125;    // MARK: - Private methods    private func itemView(index: Int) -&gt; some View &#123;        let foregroundColor = selection == index ? configuration.selectTextColor : configuration.textColor        let paddingHorizontal: CGFloat            = (type == .underline || type == .titleUnderline) ? 0.0 : 10.0        return ZStack &#123;            VStack &#123;                Spacer()                Text(items[index].text)                    .kerning(0.6)                    .font(.system(size: 12, weight: .medium))                    .foregroundColor(foregroundColor)                    .lineLimit(1)                    .padding(.horizontal, paddingHorizontal)                    .overlay(                        Circle()                            .strokeBorder(Color(.white), lineWidth: 1)                            .background(Circle().foregroundColor(Color(.red)))                            .frame(width: 9, height: 9)                            .opacity(items[index].markerState ? 1 : 0)                            .offset(x: 9, y: -9),                        alignment: .topTrailing                    )                Spacer()            &#125;            .frame(maxWidth: .none)            .background(                VStack &#123;                    if index == selection &amp;&amp; type == .titleUnderline &#123;                        Spacer()                        Rectangle()                            .fill(Color(.black))                                .frame(height: 2)                    &#125;                &#125;            )        &#125;        .frame(maxWidth: isFullWidth ? .infinity : .none, maxHeight: .infinity)        .contentShape(Rectangle())        .background(            GeometryReader &#123; geo -&gt; Color in                DispatchQueue.main.async &#123;                    sizes[index] = geo.frame(in: .global).size                &#125;                return Color.clear            &#125;        )        .onTapGesture &#123;            withAnimation &#123;                selection = index                self.onSelect?(items[index], index)            &#125;        &#125;    &#125;    // MARK: - Initializer    /// Init.    public init(        type: SegmentedControlType = .underline,        selection: Binding&lt;Int&gt; = .constant(0),        items: [SegmentedTabContent],        isFullWidth: Bool = false,        onSelectTab: ((SegmentedTabContent, Int) -&gt; Void)? = nil,        configuration: SegmentedControlConfiguration? = nil,        scrollEnable: Bool? = false    ) &#123;        self.type = type        _selection = selection        self.items = items        self.isFullWidth = isFullWidth        onSelect = onSelectTab        if let config = configuration &#123;            self.configuration = config        &#125;        if let scroll = scrollEnable &#123;            self.scrollEnable = scroll        &#125;    &#125;    // content    private func content() -&gt; some View &#123;        HStack(spacing: spacingBetweenItem) &#123;            ForEach(items.indices, id: \\.self) &#123; index in                itemView(index: index)            &#125;        &#125;        .padding(.top, 3)        .background(            ZStack &#123;                if type == .underline &#123;                    contentLineBackground                &#125; else if type == .tab &#123;                    contentTabBackground                &#125; else if type == .blackRoundTab &#123;                    contentBlackTabBackground                &#125;            &#125;,            alignment: type == .underline ? .bottomLeading : .leading        )    &#125;    /// Body.    public var body: some View &#123;        VStack(alignment: .leading, spacing: 0) &#123;            if scrollEnable &#123;                ScrollView(.horizontal) &#123;                    content()                &#125;            &#125; else &#123;                content()            &#125;        &#125;        .frame(maxHeight: .infinity)        .frame(height: 44)    &#125;&#125;\nDemonstration:\n\n\n","categories":["Swift UI Component"]},{"title":"Swift Utility Component - UserDefaults","url":"/charles-blog/2021/11/12/userDefaults/","content":"Build a mature utility class can store &amp; read &amp; delete local cashed defaults.                           \nPreface：we always facing requirements from business team/PO in the daily development work, which like following cases :\na). when customer login back after exsiting App, login screen username expected as profile name or nickname.\nb). lets say there is a screen has carousel cards , or the muti-view component, customer logout from this screen with a specsific indicator index, we are expected back to same card indicator or specific view after customer next logon.\n…\nAnalysis：For the above business scenarios, we need to store the user’s login name, and passing the index of the current view into userdefaults when exiting the app, then read the stored key value after opening App.\nSo, Its time to build a completely, flexibility, Out-of-the-box userDefaults utility.\nImplementation:Step1, we build a Class that represents user actions UserAction.swiftimport Foundationpublic enum UserAction: String &#123;    case firstLogin    case indicatorIndex    public var name: Stirng &#123;        rawValue    &#125;&#125;\n\nhere we define a enum struct which type is String , and give a name as the key value we will pass to UserDefault later.\nStep2, we define a DataStore protocol, class which conform to this protocl expected overwrite the function methods(write, read, delete) inside the protocol.import Foundationimport Combinepublic protocol DataStore &#123;    func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt;    func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func delete1(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\n\nyou may noticed that above three methods will return a new publisher.\nStep3, we need a UserDefaultsStore.swift class to conform this protocol.import Foundationimport Combinepublic class UserDefaultsStore: DataStore &#123;    private let userDefaults: UserDefaults    private let decoder: JSONDecoder    private let encoder: JSONEncoder        init(        userDefaults: UserDefaults,        decoder: JSONDecoder,        encoder: JSONEncoder    ) &#123;        self.userDefaults = userDefaults        self.decoder = decoder        self.encoder = encoder    &#125;        public func read&lt;T: Decodable&gt;(_ key: String) -&gt; AnyPublisher&lt;T?, Error&gt; &#123;        Just(key)            .tryMap &#123; key -&gt; T? in                guard let data = userDefaults.data(forKey: key) else &#123; return nil &#125;                return try decoder.decode(T.self, from: data)            &#125;.eraseToAnyPublisher()    &#125;        public func write&lt;T: Encodable&gt;(_ key: String, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        Just(())            .tryMap &#123; emptyValue -&gt; Void in                let data = try encoder.encode(value)                userDefaults.set(data, forKey: key)                return emptyValue            &#125;.eraseToAnyPublisher()            &#125;        public func delete(_ key: String) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaults.removeObject(forKey: key)        return Just(()).setFailureType(to: Error.self).eraseToAnyPublisher()    &#125;&#125;\nStep4, we will build a StandardUserActionsManager Class, and make the final encapsulation.A, we will define a UserActionsManager protocolpublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;\nB, lets extend UserDefaultStore, and convenience init this class by using id which passed from customer username ID or the .standard provided by systerm.public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nC, we make StandardUserActionsManager to conform UserActionsManager protocol.import Foundationimport Combinepublic protocol UserActionsManager &#123;    func writeToDefaults&lt;T: Encodable&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt;    func readFromDefaults&lt;T: Decodable&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt;    func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt;&#125;public class StandardUserActionsManager: UserActionsManager &#123;        private let userDefaultsStore: UserDefaultsStore    private var cancellabes = Set&lt;AnyCancellable&gt;()        init(        userDefaultsStore: UserDefaultsStore    ) &#123;        self.userDefaultsStore = userDefaultsStore    &#125;            public func writeToDefaults&lt;T&gt;(_ userAction: UserAction, value: T) -&gt; AnyPublisher&lt;Void, Error&gt; where T : Encodable &#123;        userDefaultsStore            .write(userAction.name, value: value)            .eraseToAnyPublisher()    &#125;        public func readFromDefaults&lt;T&gt;(_ userAction: UserAction) -&gt; AnyPublisher&lt;T?, Error&gt; where T : Decodable &#123;        userDefaultsStore            .read(userAction.name)            .eraseToAnyPublisher()    &#125;        public func removeFromDefaults(_ userAction: UserAction) -&gt; AnyPublisher&lt;Void, Error&gt; &#123;        userDefaultsStore            .delete(userAction.name)            .eraseToAnyPublisher()    &#125;    &#125;public extension UserDefaultsStore &#123;    convenience init?(        userId: String,        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        guard let customUserDefaults = UserDefaults(suiteName: userId) else &#123; return nil &#125;        self.init(            userDefaults: customUserDefaults,            decoder: decoder,            encoder: encoder        )    &#125;        convenience init(        decoder: JSONDecoder = JSONDecoder(),        encoder: JSONEncoder = JSONEncoder()    ) &#123;        self.init(            userDefaults: .standard,            decoder: decoder,            encoder: encoder        )    &#125;&#125;\nIn this way, our UserDefaults Utility is completed. When we introduce the function of storage and reading in the business, we directly instantiate this class to realize the requirements.\nDemo Testing:After tapping the = sign here, a calculation result will be displayed. if we do not store and read defaults, when we exit the app, the result will obviously be cleared. After we finish storing and reading, the calculation result will still be displayed after opening the app.\n\n","categories":["Swift Utility Component"]},{"title":"Swift Notebook - @ViewBuilder","url":"/charles-blog/2021/11/12/viewBuilder/","content":"Alright, id say if you want to use @ViewBuilder, I ventured infer that the basic swiftUI elements and components can no longer meet the complex requirements or customization requirements of your project. We need to DIY the more extensible view.  \nToday, let’s take a good look at this @ViewBuilder\nimport SwiftUIstruct ContentView: View &#123;    var body: some View &#123;        HStack&#123;            Text(&quot;hello&quot;)            Text(&quot;world&quot;)        &#125;    &#125;&#125;\nVery simple hello world level swiftUI code huh? as all we know, in the world of swiftUI, everything is a view, but have you ever thought about why we put two text views in hstack, so they can be aligned horizontally, and why hstack can accept two views?   \nLet’s click into hstack’s definition to have a look:\n@inlinable public init(    alignment: VerticalAlignment = .center,    spacing: CGFloat? = nil,    @ViewBuilder content: () -&gt; Content)\nFrom the source code, we can see that there is a closure content modified by @Viewbuilder in the init method, which means that the expression inside the closure needs to be processed by @Viewbuilder. How to handle it? When compiling the closure decorated by @Viewbuilder, swift will first try to find the static buildblock method in the @Viewbuilder structure. This method has two views as parameters. \nLet’s take a look first:\n@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *)extension ViewBuilder &#123;    public static func buildBlock&lt;C0, C1&gt;(_ c0: C0, _ c1: C1) -&gt; TupleView&lt;(C0, C1)&gt; where C0 : View, C1 : View&#125;\nFrom the source code of this viewbuilder, we can see that it receives two views as input parameters and returns a tupleview combined with two views.If you read the source code, you will find other statements:\n@available(iOS 13.0, macOS 10.15, tvOS 13.0, watchOS 6.0, *)extension ViewBuilder &#123;    public static func buildBlock&lt;C0, C1, C2, C3, C4, C5, C6, C7, C8, C9&gt;(_ c0: C0, _ c1: C1, _ c2: C2, _ c3: C3, _ c4: C4, _ c5: C5, _ c6: C6, _ c7: C7, _ c8: C8, _ c9: C9) -&gt; TupleView&lt;(C0, C1, C2, C3, C4, C5, C6, C7, C8, C9)&gt; where C0 : View, C1 : View, C2 : View, C3 : View, C4 : View, C5 : View, C6 : View, C7 : View, C8 : View, C9 : View&#125;\nWhat is tupleview?\n\nTupleview is a view created from a quick tuple of view values. Tupleview has no logic inside. It only keeps the view. Tupleview is completely transparent and behaves like its parent view. This means that when you put it into hstack, tupleview will place the view from tuples horizontally.\n\nAlright, now that we understand the role of @Viewbuilder, let’s think about how to use it.\nSuppose we want to do notification function for our app. First, we think that this notification should be componentized, but the content of our notification should be diversified and customized. oh yeah, we can use @Viewbuilder.\nimport SwiftUIstruct NotificationView&lt;Content: View&gt;: View &#123;    let content: Content    init(@ViewBuilder content: () -&gt; Content) &#123;        self.content = content()    &#125;    var body: some View &#123;        content            .padding()            .background(Color(.tertiarySystemBackground))            .cornerRadius(16)            .transition(.move(edge: .top))            .animation(.spring())    &#125;&#125;\nWe build a notificationview here. In this view, we draw the basic style of notification, but the type of content is a closure decorated by @Viewbuilder. This lays a foundation for us to customize the push content later.\nWhen we want to use this notificationview, we can:\nimport SwiftUIstruct ContentView: View &#123;    @State private var notificationShown = false    var body: some View &#123;        VStack &#123;            if self.notificationShown &#123;                NotificationView &#123;                    Text(&quot;notification&quot;)                &#125;            &#125;            Spacer()            Button(&quot;toggle&quot;) &#123;                self.notificationShown.toggle()            &#125;            Spacer()        &#125;    &#125;&#125;","categories":["Swift Notebook"]}]